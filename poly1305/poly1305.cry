module poly1305 where 

type Poly1305Ctx = {
    acc : [6][32],    // The intermediate data of the acc, must be greater than 130 bits.
    r : [4][32],      // Key information r, 16 bytes, that is, 4 * sizeof(uint32_t)
    s : [4][32]       // Key information s, 16 bytes, that is, 4 * sizeof(uint32_t)
}

// --- Helper functions ---
U8TOU32 : [4][8] -> [32]
U8TOU32 p = join (reverse p)

u32tou64 : [32] -> [64]
u32tou64 x = zero # x

u64tou32 : [64] -> [32]
u64tou32 x = drop`{32} x

GET_UINT32_LE : {n}(fin n) => [n][8] -> Integer -> [32]
GET_UINT32_LE key i = key@(3+i) # key@(2+i) # key@(1+i) # key@(0+i)

// --- Core block processing functions ---

testInput = [0, 0, 0, 0, 0, 0, 0, 0, 252, 255, 255, 15, 0, 0, 0, 0]
testopaque = [0,5,5,0,18446744069414584320,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]

testp = {acc = [0x08bed685, 0x08bed685, 0x08bed685, 0x08bed685, 0x08bed685, 0x08bed685],
        r = [0x08bed685, 0x08bed685, 0x08bed685, 0x08bed685],
        s = [0x08bed685, 0x036d5554, 0x0e52447c, 0x0806d540]}

Poly1305Block : {n} (fin n, n >= 16, 64 >= width n) => Poly1305Ctx -> [n][8] -> [32] -> Poly1305Ctx
Poly1305Block ctx inp padbit = 
    {acc = acc' # [0], r = ctx.r, s = ctx.s}  // 明确指定所有字段
  where
    acc = ctx.acc
    r = ctx.r
    acc' = poly1305_block (take`{5} acc) r inp padbit `n 0



poly1305_block : {n} (fin n) => [5][32] -> [4][32] -> [n][8] -> [32] -> [64] -> Integer -> [5][32]
poly1305_block a r inp padbit len off = next_state
    where
        inp0  = u32tou64 (GET_UINT32_LE inp off)
        inp4  = u32tou64 (GET_UINT32_LE inp (off + 4))
        inp8  = u32tou64 (GET_UINT32_LE inp (off + 8))
        inp12 = u32tou64 (GET_UINT32_LE inp (off + 12))

        a0_64 = u32tou64 (a@0)
        a1_64 = u32tou64 (a@1)
        a2_64 = u32tou64 (a@2)
        a3_64 = u32tou64 (a@3)
        a4_64 = u32tou64 (a@4)
        
        b0 = a0_64 + inp0
        b1 = a1_64 + inp4 + (b0 >> 32)
        b2 = a2_64 + inp8 + (b1 >> 32)
        b3 = a3_64 + inp12 + (b2 >> 32)
        
        a0 = u64tou32 b0
        a1 = u64tou32 b1
        a2 = u64tou32 b2
        a3 = u64tou32 b3
        a4 =  ((a@4) + (u64tou32 (b3 >> 32)) + padbit)

        // 多项式乘法
        r0_64 = u32tou64 (r@0)
        r1_64 = u32tou64 (r@1)
        r2_64 = u32tou64 (r@2)
        r3_64 = u32tou64 (r@3)
        
        // //b'
        m0 = (u32tou64 a0) * r0_64
        m1 = (u32tou64 a0) * r1_64 + (u32tou64 a1) * r0_64
        m2 = (u32tou64 a0) * r2_64 + (u32tou64 a1) * r1_64 + (u32tou64 a2) * r0_64
        m3 = (u32tou64 a0) * r3_64 + (u32tou64 a1) * r2_64 + (u32tou64 a2) * r1_64 + (u32tou64 a3) * r0_64
        
        m4 = (u32tou64 a1) * r3_64 + (u32tou64 a2) * r2_64 + (u32tou64 a3) * r1_64
        m5 = (u32tou64 a2) * r3_64 + (u32tou64 a3) * r2_64 + (u32tou64 a4) * r1_64
        m6 = (u32tou64 a3) * r3_64 + (u32tou64 a4) * r2_64
        m7 = (u32tou64 a4) * r3_64

        // 高位乘以5/4
        m4' = (m4 >> 2) + m4
        m5' = (m5 >> 2) + m5
        m6' = (m6 >> 2) + m6
        m7' = (m7 >> 2) + m7

        // // 进位与约简
        mask32_64 = u32tou64 0xFFFFFFFF
        acc_b0 = m0 + (m4' && mask32_64)
        acc_b1 = m1 + (acc_b0 >> 32) + (m4' >> 32) + (m5' && mask32_64)
        acc_b2 = m2 + (acc_b1 >> 32) + (m5' >> 32) + (m6' && mask32_64)
        acc_b3 = m3 + (acc_b2 >> 32) + (m6' >> 32) + (m7' && mask32_64)
        
        // // 处理a4，注意类型转换
        a4_r0 =  a4 * (r@0)
        b3_high = acc_b3 >> 32
        m7_high = m7' >> 32
        a4_new = a4_r0 + (u64tou32 (b3_high >> 32)) + (u64tou32 (m7_high >> 32))
        
        // // 计算b0-b3的32位值
        b0_32 = u64tou32 acc_b0
        b1_32 = u64tou32 acc_b1
        b2_32 = u64tou32 acc_b2
        b3_32 = u64tou32 acc_b3
        
        // // 处理a4的高位部分
        a4_high = a4_new >> 2
        a4_masked = a4_new && 0xFFFFFFFC
        a4_combined = a4_high + a4_masked   //b0
        
        // // 计算最终结果
        final_b0 = (u32tou64 b0_32) + (u32tou64 a4_combined)
        final_b1 = (u32tou64 b1_32) +  (final_b0 >> 32)
        final_b2 = (u32tou64 b2_32) +  (final_b1 >> 32)
        final_b3 = (u32tou64 b3_32) +  (final_b2 >> 32)
        final_a4 = (u32tou64 (a4_new && 0x00000003)) + (final_b3 >> 32)

        // 组装最终结果
        next_state = [u64tou32 final_b0, u64tou32 final_b1, u64tou32 final_b2, u64tou32 final_b3, u64tou32 final_a4]
        //next_state = [a0, a1, a2, a3, a4]
        
        // 更新状态并递归处理下一个块
        // len' = len - 16
        // hout = if len' < 16 then next_state
        //        else poly1305_block next_state r inp padbit len' (off + 16)


//                 m5 = u32tou64 a2 * u32tou64 (r@3) + u32tou64 a3 * u32tou64 (r@2) + u32tou64 a4 * u32tou64 (r@1)
//                 m6 = u32tou64 a3 * u32tou64 (r@3) + u32tou64 a4 * u32tou64 (r@2)
//                 m7 = u32tou64 a4 * u32tou64 (r@3)

//                 // 3. 高位乘以5/4
//                 m4' = (m4 >> 2) + m4
//                 m5' = (m5 >> 2) + m5
//                 m6' = (m6 >> 2) + m6
//                 m7' = (m7 >> 2) + m7

//                 // 4. 进位与约简
//                 b0' = m0 + (m4' & 0xFFFFFFFF)
//                 b1' = m1 + (b0' >> 32) + (m4' >> 32) + (m5' & 0xFFFFFFFF)
//                 b2' = m2 + (b1' >> 32) + (m5' >> 32) + (m6' & 0xFFFFFFFF)
//                 b3' = m3 + (b2' >> 32) + (m6' >> 32) + (m7' & 0xFFFFFFFF)
//                 a4' = a4 * (r@0) + (u64tou32 (b3' >> 32)) + (u64tou32 (m7' >> 32))
//                 b0f = u64tou32 b0'
//                 b1f = u64tou32 b1'
//                 b2f = u64tou32 b2'
//                 b3f = u64tou32 b3'
//                 b0f' = b0f + (a4' >> 2) + (a4' & 0xFFFFFFFC)
//                 a4f = a4' & 0x3

//                 // 5. carry
//                 b1f' = b1f + (b0f' >> 32)
//                 b2f' = b2f + (b1f' >> 32)
//                 b3f' = b3f + (b2f' >> 32)
//                 a4f' = a4f + (b3f' >> 32)

//                 // 6. 更新a
//                 a' = [u64tou32 b0f', u64tou32 b1f', u64tou32 b2f', u64tou32 b3f', a4f']
//                 block(a', len-16, off+16)
//         acc' = block([acc@0, acc@1, acc@2, acc@3, acc@4], width inp, 0)
//         ctx' = ctx { acc = acc' # [0] } // 保持acc为6元素


