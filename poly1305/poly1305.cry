module poly1305 where 
import poly_rfc

type Poly1305Ctx = {
    acc : [6][32],    // The intermediate data of the acc, must be greater than 130 bits.
    r : [4][32],      // Key information r, 16 bytes, that is, 4 * sizeof(uint32_t)
    s : [4][32]       // Key information s, 16 bytes, that is, 4 * sizeof(uint32_t)
}

// --- Helper functions ---
U8TOU32 : [4][8] -> [32]
U8TOU32 p = join (reverse p)

u32tou64 : [32] -> [64]
u32tou64 x = zero # x

u64tou32 : [64] -> [32]
u64tou32 x = drop`{32} x

GET_UINT32_LE : {n}(fin n) => [n][8] -> Integer -> [32]
GET_UINT32_LE key i = key@(3+i) # key@(2+i) # key@(1+i) # key@(0+i)

// 64位转小端字节序，取低32位
PUT_UINT32_LE : [64] -> [4][8]
PUT_UINT32_LE x = reverse (split`{4} (drop`{32} x))

// --- Core block processing functions ---
Poly1305Block : {n} (fin n, n >= 16, 32 >= width n) => Poly1305Ctx -> [n][8] -> [32] -> Poly1305Ctx
Poly1305Block ctx inp padbit = 
    {acc = acc' # [0], r = ctx.r, s = ctx.s}  // 明确指定所有字段
  where
    acc = ctx.acc
    r = ctx.r
    acc' = poly1305_block (take`{5} acc) r inp padbit `n 0


poly1305_block : {n} (fin n) => [5][32] -> [4][32] -> [n][8] -> [32] -> [32] -> Integer -> [5][32]
poly1305_block a r inp padbit len off = hout
    where
        inp0  = u32tou64 (GET_UINT32_LE inp off)
        inp4  = u32tou64 (GET_UINT32_LE inp (off + 4))
        inp8  = u32tou64 (GET_UINT32_LE inp (off + 8))
        inp12 = u32tou64 (GET_UINT32_LE inp (off + 12))

        a0_64 = u32tou64 (a@0)
        a1_64 = u32tou64 (a@1)
        a2_64 = u32tou64 (a@2)
        a3_64 = u32tou64 (a@3)
        a4_64 = u32tou64 (a@4)
        
        b0 = a0_64 + inp0
        b1 = a1_64 + inp4 + (b0 >> 32)
        b2 = a2_64 + inp8 + (b1 >> 32)
        b3 = a3_64 + inp12 + (b2 >> 32)
        
        a0 = u64tou32 b0
        a1 = u64tou32 b1
        a2 = u64tou32 b2
        a3 = u64tou32 b3
        a4 =  ((a@4) + (u64tou32 (b3 >> 32)) + padbit)

        // 多项式乘法
        r0_64 = u32tou64 (r@0)
        r1_64 = u32tou64 (r@1)
        r2_64 = u32tou64 (r@2)
        r3_64 = u32tou64 (r@3)
        
        // //b'
        m0 = (u32tou64 a0) * r0_64
        m1 = (u32tou64 a0) * r1_64 + (u32tou64 a1) * r0_64
        m2 = (u32tou64 a0) * r2_64 + (u32tou64 a1) * r1_64 + (u32tou64 a2) * r0_64
        m3 = (u32tou64 a0) * r3_64 + (u32tou64 a1) * r2_64 + (u32tou64 a2) * r1_64 + (u32tou64 a3) * r0_64
        
        m4 = (u32tou64 a1) * r3_64 + (u32tou64 a2) * r2_64 + (u32tou64 a3) * r1_64
        m5 = (u32tou64 a2) * r3_64 + (u32tou64 a3) * r2_64 + (u32tou64 a4) * r1_64
        m6 = (u32tou64 a3) * r3_64 + (u32tou64 a4) * r2_64
        m7 = (u32tou64 a4) * r3_64

        // 高位乘以5/4
        m4' = (m4 >> 2) + m4
        m5' = (m5 >> 2) + m5
        m6' = (m6 >> 2) + m6
        m7' = (m7 >> 2) + m7

        // // 进位与约简
        mask32_64 = u32tou64 0xFFFFFFFF
        acc_b0 = m0 + (m4' && mask32_64)
        acc_b1 = m1 + (acc_b0 >> 32) + (m4' >> 32) + (m5' && mask32_64)
        acc_b2 = m2 + (acc_b1 >> 32) + (m5' >> 32) + (m6' && mask32_64)
        acc_b3 = m3 + (acc_b2 >> 32) + (m6' >> 32) + (m7' && mask32_64)
        
        // // 处理a4，注意类型转换
        a4_r0 =  a4 * (r@0)
        b3_high = acc_b3 >> 32
        m7_high = m7' >> 32
        a4_new = a4_r0 + (u64tou32 b3_high) + (u64tou32 m7_high)
        
        // // 计算b0-b3的32位值
        b0_32 = u64tou32 acc_b0
        b1_32 = u64tou32 acc_b1
        b2_32 = u64tou32 acc_b2
        b3_32 = u64tou32 acc_b3
        
        // // 处理a4的高位部分
        a4_high = a4_new >> 2
        a4_masked = a4_new && 0xFFFFFFFC
        a4_combined = a4_high + a4_masked   //b0
        
        // // 计算最终结果
        final_b0 = (u32tou64 b0_32) + (u32tou64 a4_combined)
        final_b1 = (u32tou64 b1_32) +  (final_b0 >> 32)
        final_b2 = (u32tou64 b2_32) +  (final_b1 >> 32)
        final_b3 = (u32tou64 b3_32) +  (final_b2 >> 32)
        final_a4 = (u32tou64 (a4_new && 0x00000003)) + (final_b3 >> 32)

        // 组装最终结果
        next_state = [u64tou32 final_b0, u64tou32 final_b1, u64tou32 final_b2, u64tou32 final_b3, u64tou32 final_a4]
        //next_state = [a0, a1, a2, a3, a4]
        
        // 更新状态并递归处理下一个块
        len' = len - 16
        hout = if len' < 16 then next_state
               else poly1305_block next_state r inp padbit len' (off + 16)


// Poly1305Last 建模
Poly1305Last : Poly1305Ctx -> [16][8]
Poly1305Last ctx = mac
    where
        a = take`{5} ctx.acc
        s = ctx.s
        // 进位加法，判断是否大于p
        b0 = (u32tou64 (a@0)) + 5
        b1 = (u32tou64 (a@1)) + (b0 >> 32)
        b2 = (u32tou64 (a@2)) + (b1 >> 32)
        b3 = (u32tou64 (a@3)) + (b2 >> 32)
        b4 = (u32tou64 (a@4)) + (b3 >> 32)
        // 判断是否大于p
        is_carry = ((b4 && 0x0000000000000004) == 0)
        // 如果没有进位，b[0..3] = a[0..3]
        b0' = if is_carry then u32tou64 (a@0) else b0
        b1' = if is_carry then u32tou64 (a@1) else b1
        b2' = if is_carry then u32tou64 (a@2) else b2
        b3' = if is_carry then u32tou64 (a@3) else b3
        // 加上s
        t0 = u32tou64 (s@0) + (b0' && 0x00000000FFFFFFFF)
        t1 = u32tou64 (s@1) + (b1' && 0x00000000FFFFFFFF) + (t0 >> 32)
        t2 = u32tou64 (s@2) + (b2' && 0x00000000FFFFFFFF) + (t1 >> 32)
        t3 = u32tou64 (s@3) + (b3' && 0x00000000FFFFFFFF) + (t2 >> 32)
        // 输出为16字节小端
        mac = join [PUT_UINT32_LE t0, PUT_UINT32_LE t1, PUT_UINT32_LE t2, PUT_UINT32_LE t3]


poly1305_init : [32][8] -> Poly1305Ctx
poly1305_init key = ctx
    where ctx = {acc = [0,0,0,0,0,0],
          r = [U8TOU32 (key'@0), U8TOU32 (key'@1), U8TOU32 (key'@2), U8TOU32 (key'@3)],
          s = nonce }
          key' = groupBy`{4} key
          nonce = (chacounter (drop`{16} key))


to16 : {n}(fin n, n < 16) => [n][8] -> [16][8]
to16 inp = inp # [0x01] # zero

chacounter : [16][8] -> [4][32]
chacounter key = out'
    where key32 = groupBy`{32} (join key)
          out = [ reverse (split`{4} keyt) | keyt <- key32 ]
          out' = groupBy`{32} (join (join out))


testInput = [0, 0, 0, 0, 0, 0, 0, 0, 252, 255, 255, 15, 0, 0, 0, 0]
testopaque = [0,5,5,0,18446744069414584320,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]

// testp = {acc = [0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000],
//         r = [0x00000000, 0x00000000, 0x00000000, 0x00000000],
//         s = [0x08bed685, 0x036d5554, 0x0e52447c, 0x0806d540]}

testp = {acc = [0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000],
        r = [0x08bed685, 0x036d5554, 0x0e52447c, 0x0806d540],
        s = [0x08bed685, 0x036d5554, 0x0e52447c, 0x0806d540]}


tp2 = {h = [0x344b30de, 0xcccfb4ea, 0xb0337fa7, 0xd8adaf23, 0x00000002],
        r = [0x08bed685, 0x036d5554, 0x0e52447c, 0x0806d540]}


tkey = [0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x36,0xe5,0xf6,0xb5,0xc5,0xe0,0x60,0x70,
  0xf0,0xef,0xca,0x96,0x22,0x7a,0x86,0x3e]

tinp = [0x41,0x6e,0x79,0x20,0x73,0x75,0x62,0x6d,
  0x69,0x73,0x73,0x69,0x6f,0x6e,0x20,0x74,
  0x6f,0x20,0x74,0x68,0x65,0x20,0x49,0x45,
  0x54,0x46,0x20,0x69,0x6e,0x74,0x65,0x6e,
  0x64,0x65,0x64,0x20,0x62,0x79,0x20,0x74,
  0x68,0x65,0x20,0x43,0x6f,0x6e,0x74,0x72,
  0x69,0x62,0x75,0x74,0x6f,0x72,0x20,0x66,
  0x6f,0x72,0x20,0x70,0x75,0x62,0x6c,0x69,
  0x63,0x61,0x74,0x69,0x6f,0x6e,0x20,0x61,
  0x73,0x20,0x61,0x6c,0x6c,0x20,0x6f,0x72,
  0x20,0x70,0x61,0x72,0x74,0x20,0x6f,0x66,
  0x20,0x61,0x6e,0x20,0x49,0x45,0x54,0x46,
  0x20,0x49,0x6e,0x74,0x65,0x72,0x6e,0x65,
  0x74,0x2d,0x44,0x72,0x61,0x66,0x74,0x20,
  0x6f,0x72,0x20,0x52,0x46,0x43,0x20,0x61,
  0x6e,0x64,0x20,0x61,0x6e,0x79,0x20,0x73,
  0x74,0x61,0x74,0x65,0x6d,0x65,0x6e,0x74,
  0x20,0x6d,0x61,0x64,0x65,0x20,0x77,0x69,
  0x74,0x68,0x69,0x6e,0x20,0x74,0x68,0x65,
  0x20,0x63,0x6f,0x6e,0x74,0x65,0x78,0x74,
  0x20,0x6f,0x66,0x20,0x61,0x6e,0x20,0x49,
  0x45,0x54,0x46,0x20,0x61,0x63,0x74,0x69,
  0x76,0x69,0x74,0x79,0x20,0x69,0x73,0x20,
  0x63,0x6f,0x6e,0x73,0x69,0x64,0x65,0x72,
  0x65,0x64,0x20,0x61,0x6e,0x20,0x22,0x49,
  0x45,0x54,0x46,0x20,0x43,0x6f,0x6e,0x74,
  0x72,0x69,0x62,0x75,0x74,0x69,0x6f,0x6e,
  0x22,0x2e,0x20,0x53,0x75,0x63,0x68,0x20,
  0x73,0x74,0x61,0x74,0x65,0x6d,0x65,0x6e,
  0x74,0x73,0x20,0x69,0x6e,0x63,0x6c,0x75,
  0x64,0x65,0x20,0x6f,0x72,0x61,0x6c,0x20,
  0x73,0x74,0x61,0x74,0x65,0x6d,0x65,0x6e,
  0x74,0x73,0x20,0x69,0x6e,0x20,0x49,0x45,
  0x54,0x46,0x20,0x73,0x65,0x73,0x73,0x69,
  0x6f,0x6e,0x73,0x2c,0x20,0x61,0x73,0x20,
  0x77,0x65,0x6c,0x6c,0x20,0x61,0x73,0x20,
  0x77,0x72,0x69,0x74,0x74,0x65,0x6e,0x20,
  0x61,0x6e,0x64,0x20,0x65,0x6c,0x65,0x63,
  0x74,0x72,0x6f,0x6e,0x69,0x63,0x20,0x63,
  0x6f,0x6d,0x6d,0x75,0x6e,0x69,0x63,0x61,
  0x74,0x69,0x6f,0x6e,0x73,0x20,0x6d,0x61,
  0x64,0x65,0x20,0x61,0x74,0x20,0x61,0x6e,
  0x79,0x20,0x74,0x69,0x6d,0x65,0x20,0x6f,
  0x72,0x20,0x70,0x6c,0x61,0x63,0x65,0x2c,
  0x20,0x77,0x68,0x69,0x63,0x68,0x20,0x61,
  0x72,0x65,0x20,0x61,0x64,0x64,0x72,0x65,
  0x73,0x73,0x65,0x64,0x20,0x74,0x6f]


tkey2 = [0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]
tinp2 =  [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0xfe, 0xff, 0xff, 0x5f, 0xff, 0xff, 0xff,
   0xaf, 0xff, 0xff, 0xff, 0xd7, 0x01, 0x00, 0x98, 0x99, 0x00, 0x00]

poly_mac : {n}(fin n, n>=16, 32 >= width n) => [32][8] -> [n][8] -> [16][8] 
poly_mac key inp = mac 
    where st1 = poly1305_init key
          st2 = Poly1305Block st1 inp 1
          remain = `n % 16 
          st3 = if remain != 0 then Poly1305Block st2 (to16 (drop`{(n/16)*16} inp)) 1
                else st2   
          mac = Poly1305Last st3